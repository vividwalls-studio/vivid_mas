{
  "name": "VividWalls Prompt Chain Image Retrieval & Selection",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "prompt-chain-retrieval",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "user-inquiry-webhook",
      "name": "User Inquiry Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "vividwalls-prompt-chain"
    },
    {
      "parameters": {
        "jsCode": "// Parse and analyze user inquiry for database retrieval\nconst body = $input.first().json.body;\n\n// Extract user inquiry details\nconst userInquiry = body.inquiry || body.question || body.message || '';\nconst roomType = body.roomType || null;\nconst stylePreference = body.stylePreference || null;\nconst colorPreferences = body.colorPreferences || [];\nconst moodPreference = body.moodPreference || null;\nconst sizeRequirements = body.sizeRequirements || null;\nconst sessionId = body.sessionId || `session_${Date.now()}`;\nconst userId = body.userId || 'anonymous';\n\n// Validate inquiry\nif (!userInquiry || userInquiry.trim().length === 0) {\n  throw new Error('User inquiry is required');\n}\n\n// Prepare for first prompt chain step\nreturn {\n  originalInquiry: userInquiry,\n  roomType,\n  stylePreference,\n  colorPreferences,\n  moodPreference,\n  sizeRequirements,\n  sessionId,\n  userId,\n  timestamp: new Date().toISOString(),\n  step: 'inquiry_analysis',\n  chainId: `chain_${Date.now()}`\n};"
      },
      "id": "parse-user-inquiry",
      "name": "Parse User Inquiry",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "operation": "text",
        "options": {
          "systemMessage": "You are VividWalls Database Query AI, specialized in analyzing user inquiries and extracting precise search parameters for artwork database retrieval.\n\n## YOUR ROLE:\nAnalyze user inquiries about room decoration and artwork needs, then extract specific database search parameters including tags, categories, colors, moods, and styles.\n\n## ANALYSIS FRAMEWORK:\n\n### ROOM TYPE EXTRACTION:\n- **Living Spaces**: living room, family room, great room, lounge\n- **Private Spaces**: bedroom, master bedroom, guest bedroom, nursery\n- **Work Spaces**: home office, study, library, workspace\n- **Functional Spaces**: kitchen, dining room, bathroom, hallway, entryway\n- **Specialized Spaces**: meditation room, yoga space, home gym, basement, sunroom, powder room\n\n### STYLE CLASSIFICATION:\n- **Modern**: minimalist, contemporary, clean lines, geometric\n- **Traditional**: classic, formal, elegant, sophisticated\n- **Industrial**: loft, exposed brick, urban, raw materials\n- **Farmhouse**: rustic, organic, natural, warm wood\n- **Maximalist**: bold, eclectic, pattern-rich, vibrant\n- **Transitional**: blend of modern and traditional\n\n### COLOR ANALYSIS:\n- **Warm Colors**: red, orange, yellow, coral, burgundy, gold\n- **Cool Colors**: blue, green, purple, teal, navy, mint\n- **Neutral Colors**: white, gray, beige, black, brown, cream\n- **Color Relationships**: complementary, analogous, monochromatic, triadic\n\n### MOOD EXTRACTION:\n- **Energizing**: stimulating, vibrant, active, motivating\n- **Calming**: peaceful, serene, relaxing, soothing\n- **Sophisticated**: elegant, refined, professional, mature\n- **Playful**: fun, creative, youthful, dynamic\n- **Romantic**: intimate, warm, cozy, soft\n- **Dramatic**: bold, striking, high-contrast, impactful\n- **Natural**: organic, earthy, grounded, harmonious\n- **Mysterious**: intriguing, complex, deep, contemplative\n\n### SIZE REQUIREMENTS:\n- **Small**: 12x16, 16x20, 20x24 inches\n- **Medium**: 24x36, 30x40 inches\n- **Large**: 36x48, 48x36, 53x72 inches\n- **Gallery Wall**: multiple coordinated pieces\n\n### COLLECTION MAPPING:\n- **Geometric Intersection**: clean lines, modern, minimalist\n- **Geometric Symmetry**: balanced, structured, professional\n- **Chromatic Echoes**: warm colors, emotional, vibrant\n- **Resonant Structure**: cool tones, calming, sophisticated\n- **Intersecting Spaces**: dramatic, high contrast, bold\n- **Shape Emergence**: organic forms, natural, flowing\n- **Fractal Color**: complex patterns, energizing, creative\n- **Mosaics**: textured, layered, rich detail\n- **Vivid Layers**: depth, dimensional, sophisticated\n\n## OUTPUT FORMAT:\nProvide structured JSON with extracted search parameters:\n\n```json\n{\n  \"searchParameters\": {\n    \"primaryTags\": [\"tag1\", \"tag2\", \"tag3\"],\n    \"secondaryTags\": [\"tag4\", \"tag5\"],\n    \"collections\": [\"collection1\", \"collection2\"],\n    \"roomTypes\": [\"room1\", \"room2\"],\n    \"colorCategories\": [\"warm\", \"cool\", \"neutral\"],\n    \"specificColors\": [\"blue\", \"gray\", \"white\"],\n    \"moodClassifications\": [\"calming\", \"sophisticated\"],\n    \"styleCategories\": [\"modern\", \"minimalist\"],\n    \"sizePreferences\": [\"large\", \"medium\"],\n    \"functionalRequirements\": [\"office-suitable\", \"bedroom-art\"]\n  },\n  \"queryPriority\": {\n    \"mustHave\": [\"primary requirements that cannot be compromised\"],\n    \"preferred\": [\"secondary preferences that are flexible\"],\n    \"avoid\": [\"elements to exclude from results\"]\n  },\n  \"databaseQuery\": {\n    \"sqlWhere\": \"SQL WHERE clause for database query\",\n    \"vectorSearch\": \"Text for vector similarity search\",\n    \"tagFilters\": [\"specific tag filters\"],\n    \"categoryFilters\": [\"category filters\"]\n  },\n  \"confidence\": 0.95,\n  \"reasoning\": \"Brief explanation of parameter extraction logic\"\n}\n```\n\n## INSTRUCTIONS:\n1. **Analyze the complete user inquiry** for explicit and implicit requirements\n2. **Extract all relevant search parameters** using the framework above\n3. **Prioritize requirements** based on user emphasis and context\n4. **Generate precise database queries** for both SQL and vector search\n5. **Provide confidence score** based on clarity of user requirements\n6. **Explain reasoning** for parameter extraction decisions\n\nAnalyze the user inquiry and extract comprehensive search parameters for artwork database retrieval."
        },
        "prompt": "=Analyze this user inquiry for VividWalls artwork database retrieval:\n\nUser Inquiry: \"{{ $json.originalInquiry }}\"\n\nAdditional Context:\n- Room Type: {{ $json.roomType || 'Not specified' }}\n- Style Preference: {{ $json.stylePreference || 'Not specified' }}\n- Color Preferences: {{ JSON.stringify($json.colorPreferences) }}\n- Mood Preference: {{ $json.moodPreference || 'Not specified' }}\n- Size Requirements: {{ $json.sizeRequirements || 'Not specified' }}\n\nExtract comprehensive search parameters for database retrieval, including tags, categories, collections, and query filters. Focus on both explicit requirements and implicit needs based on the inquiry context.",
        "model": "gpt-4-turbo-preview"
      },
      "id": "extract-search-parameters",
      "name": "Extract Search Parameters (Chain Step 1)",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Process AI response and prepare database queries\nconst aiResponse = $input.first().json.choices?.[0]?.message?.content || '';\nconst originalData = $('parse-user-inquiry').first().json;\n\n// Parse JSON response from AI\nlet searchParams;\ntry {\n  const jsonMatch = aiResponse.match(/```json\\s*([\\s\\S]*?)\\s*```/) || aiResponse.match(/{[\\s\\S]*}/);\n  if (jsonMatch) {\n    searchParams = JSON.parse(jsonMatch[1] || jsonMatch[0]);\n  } else {\n    throw new Error('No valid JSON found in AI response');\n  }\n} catch (error) {\n  // Fallback: create basic search parameters\n  searchParams = {\n    searchParameters: {\n      primaryTags: ['abstract', 'modern'],\n      collections: ['Geometric Intersection'],\n      moodClassifications: ['sophisticated'],\n      styleCategories: ['modern']\n    },\n    confidence: 0.5,\n    reasoning: 'Fallback parameters due to parsing error'\n  };\n}\n\n// Prepare multiple database query strategies\nconst queries = {\n  // Vector similarity search\n  vectorQuery: {\n    searchText: createVectorSearchText(searchParams, originalData),\n    limit: 20,\n    threshold: 0.7\n  },\n  \n  // Tag-based search\n  tagQuery: {\n    tags: [...(searchParams.searchParameters.primaryTags || []), \n           ...(searchParams.searchParameters.secondaryTags || [])],\n    collections: searchParams.searchParameters.collections || [],\n    limit: 15\n  },\n  \n  // Category-based search\n  categoryQuery: {\n    roomTypes: searchParams.searchParameters.roomTypes || [],\n    moodClassifications: searchParams.searchParameters.moodClassifications || [],\n    styleCategories: searchParams.searchParameters.styleCategories || [],\n    limit: 10\n  },\n  \n  // Color-based search\n  colorQuery: {\n    colorCategories: searchParams.searchParameters.colorCategories || [],\n    specificColors: searchParams.searchParameters.specificColors || [],\n    limit: 12\n  }\n};\n\n// Helper function to create vector search text\nfunction createVectorSearchText(params, originalData) {\n  const elements = [\n    originalData.originalInquiry,\n    ...(params.searchParameters.primaryTags || []),\n    ...(params.searchParameters.moodClassifications || []),\n    ...(params.searchParameters.styleCategories || []),\n    ...(params.searchParameters.roomTypes || [])\n  ];\n  return elements.join(' ');\n}\n\nreturn {\n  ...originalData,\n  searchParameters: searchParams,\n  databaseQueries: queries,\n  step: 'database_retrieval',\n  processingTime: new Date().toISOString()\n};"
      },
      "id": "prepare-database-queries",
      "name": "Prepare Database Queries",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "split-query-types",
      "name": "Split Query Types",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "jsCode": "// Execute real database queries using the VividWalls PostgreSQL database\nconst queryData = $input.first().json;\nconst queries = queryData.databaseQueries;\n\n// Prepare parameters for database queries\nconst vectorParams = {\n  searchText: queries.vectorQuery.searchText,\n  embeddingType: 'comprehensive',\n  threshold: queries.vectorQuery.threshold,\n  limit: queries.vectorQuery.limit\n};\n\nconst tagParams = {\n  primaryTags: queries.tagQuery.tags.slice(0, 5), // Limit to first 5 tags\n  secondaryTags: queries.tagQuery.tags.slice(5, 10), // Next 5 tags as secondary\n  tagSources: ['ai_analysis', 'manual', 'auto_generated'],\n  minConfidence: 0.6,\n  limit: queries.tagQuery.limit\n};\n\nconst categoryParams = {\n  collections: queries.categoryQuery.collections,\n  roomTypes: queries.categoryQuery.roomTypes,\n  moodClassifications: queries.categoryQuery.moodClassifications,\n  styleCategories: queries.categoryQuery.styleCategories,\n  limit: queries.categoryQuery.limit\n};\n\nconst colorParams = {\n  colorCategories: queries.colorQuery.colorCategories,\n  specificColors: queries.colorQuery.specificColors,\n  colorTemperature: null, // Will be determined by AI analysis\n  limit: queries.colorQuery.limit\n};\n\n// Return prepared parameters for database nodes\nreturn {\n  ...queryData,\n  databaseParams: {\n    vector: vectorParams,\n    tag: tagParams,\n    category: categoryParams,\n    color: colorParams\n  },\n  step: 'database_query_prepared',\n  queryPreparationTime: new Date().toISOString()\n};"
      },
      "id": "execute-database-queries",
      "name": "Prepare Real Database Queries",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Vector similarity search for products\nSELECT \n    p.id,\n    p.handle,\n    p.title,\n    p.collection,\n    pa.primary_mood,\n    pa.dominant_colors,\n    pa.recommended_rooms,\n    pi.cdn_url as image_url,\n    pv.price,\n    pv.frame_size,\n    1 - (pe.embedding <=> $1::vector) AS similarity_score\nFROM product_embeddings pe\nJOIN products p ON pe.product_id = p.id\nLEFT JOIN product_analysis pa ON p.id = pa.product_id\nLEFT JOIN product_images pi ON p.id = pi.product_id AND pi.is_primary = true\nLEFT JOIN product_variants pv ON p.id = pv.product_id\nWHERE pe.embedding_type = $2\nAND 1 - (pe.embedding <=> $1::vector) >= $3\nAND p.published = true\nORDER BY pe.embedding <=> $1::vector\nLIMIT $4;",
        "additionalFields": {
          "mode": "list"
        }
      },
      "id": "vector-similarity-search",
      "name": "Vector Similarity Search",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1560, 100],
      "credentials": {
        "postgres": {
          "id": "vividwalls-postgres",
          "name": "VividWalls PostgreSQL"
        }
      },
      "executeOnce": false
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Tag-based product search\nSELECT DISTINCT\n    p.id,\n    p.handle,\n    p.title,\n    p.collection,\n    pa.primary_mood,\n    pa.dominant_colors,\n    pa.recommended_rooms,\n    pi.cdn_url as image_url,\n    pv.price,\n    pv.frame_size,\n    AVG(pt.confidence_score) as tag_confidence,\n    COUNT(pt.tag_id) as matching_tags\nFROM products p\nJOIN product_tags pt ON p.id = pt.product_id\nJOIN tags t ON pt.tag_id = t.id\nLEFT JOIN product_analysis pa ON p.id = pa.product_id\nLEFT JOIN product_images pi ON p.id = pi.product_id AND pi.is_primary = true\nLEFT JOIN product_variants pv ON p.id = pv.product_id\nWHERE (\n    ($1::text[] IS NULL OR t.name = ANY($1::text[])) OR\n    ($2::text[] IS NULL OR t.name = ANY($2::text[]))\n)\nAND pt.tag_source = ANY($3::text[])\nAND pt.confidence_score >= $4\nAND p.published = true\nGROUP BY p.id, p.handle, p.title, p.collection, pa.primary_mood, pa.dominant_colors, pa.recommended_rooms, pi.cdn_url, pv.price, pv.frame_size\nHAVING COUNT(pt.tag_id) > 0\nORDER BY AVG(pt.confidence_score) DESC, COUNT(pt.tag_id) DESC\nLIMIT $5;",
        "additionalFields": {
          "mode": "list"
        }
      },
      "id": "tag-based-search",
      "name": "Tag-Based Search",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1560, 200],
      "credentials": {
        "postgres": {
          "id": "vividwalls-postgres",
          "name": "VividWalls PostgreSQL"
        }
      },
      "executeOnce": false
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Category and collection-based search\nSELECT DISTINCT\n    p.id,\n    p.handle,\n    p.title,\n    p.collection,\n    pa.primary_mood,\n    pa.secondary_mood,\n    pa.dominant_colors,\n    pa.recommended_rooms,\n    pa.style_compatibility,\n    pi.cdn_url as image_url,\n    pv.price,\n    pv.frame_size,\n    (\n        CASE WHEN $1::text[] IS NULL OR p.collection = ANY($1::text[]) THEN 2 ELSE 0 END +\n        CASE WHEN $2::text[] IS NULL OR pa.recommended_rooms && $2::text[] THEN 2 ELSE 0 END +\n        CASE WHEN $3::text[] IS NULL OR pa.primary_mood = ANY($3::text[]) THEN 1 ELSE 0 END +\n        CASE WHEN $4::text[] IS NULL OR pa.style_compatibility && $4::text[] THEN 1 ELSE 0 END\n    ) as category_score\nFROM products p\nLEFT JOIN product_analysis pa ON p.id = pa.product_id\nLEFT JOIN product_images pi ON p.id = pi.product_id AND pi.is_primary = true\nLEFT JOIN product_variants pv ON p.id = pv.product_id\nWHERE p.published = true\nAND (\n    ($1::text[] IS NULL OR p.collection = ANY($1::text[])) OR\n    ($2::text[] IS NULL OR pa.recommended_rooms && $2::text[]) OR\n    ($3::text[] IS NULL OR pa.primary_mood = ANY($3::text[])) OR\n    ($4::text[] IS NULL OR pa.style_compatibility && $4::text[])\n)\nORDER BY category_score DESC, p.title\nLIMIT $5;",
        "additionalFields": {
          "mode": "list"
        }
      },
      "id": "category-collection-search",
      "name": "Category & Collection Search",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1560, 300],
      "credentials": {
        "postgres": {
          "id": "vividwalls-postgres",
          "name": "VividWalls PostgreSQL"
        }
      },
      "executeOnce": false
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Color-based product search\nSELECT DISTINCT\n    p.id,\n    p.handle,\n    p.title,\n    p.collection,\n    pa.primary_mood,\n    pa.dominant_colors,\n    pa.color_temperature,\n    pa.color_harmony,\n    pa.recommended_rooms,\n    pi.cdn_url as image_url,\n    pv.price,\n    pv.frame_size,\n    (\n        CASE WHEN $1::text[] IS NULL OR pa.dominant_colors && $1::text[] THEN 3 ELSE 0 END +\n        CASE WHEN $2::text[] IS NULL OR pa.dominant_colors && $2::text[] THEN 2 ELSE 0 END +\n        CASE WHEN $3::text IS NULL OR pa.color_temperature = $3::text THEN 1 ELSE 0 END\n    ) as color_score\nFROM products p\nLEFT JOIN product_analysis pa ON p.id = pa.product_id\nLEFT JOIN product_images pi ON p.id = pi.product_id AND pi.is_primary = true\nLEFT JOIN product_variants pv ON p.id = pv.product_id\nWHERE p.published = true\nAND (\n    ($1::text[] IS NULL OR pa.dominant_colors && $1::text[]) OR\n    ($2::text[] IS NULL OR pa.dominant_colors && $2::text[]) OR\n    ($3::text IS NULL OR pa.color_temperature = $3::text)\n)\nHAVING (\n    CASE WHEN $1::text[] IS NULL OR pa.dominant_colors && $1::text[] THEN 3 ELSE 0 END +\n    CASE WHEN $2::text[] IS NULL OR pa.dominant_colors && $2::text[] THEN 2 ELSE 0 END +\n    CASE WHEN $3::text IS NULL OR pa.color_temperature = $3::text THEN 1 ELSE 0 END\n) > 0\nORDER BY color_score DESC, p.title\nLIMIT $4;",
        "additionalFields": {
          "mode": "list"
        }
      },
      "id": "color-based-search",
      "name": "Color-Based Search",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1560, 400],
      "credentials": {
        "postgres": {
          "id": "vividwalls-postgres",
          "name": "VividWalls PostgreSQL"
        }
      },
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// Aggregate and process all database search results\nconst allInputs = $input.all();\nconst queryData = $('execute-database-queries').first().json;\n\n// Collect results from different search methods\nconst searchResults = {\n  vectorResults: [],\n  tagResults: [],\n  categoryResults: [],\n  colorResults: []\n};\n\n// Map results to their respective categories based on node names\nallInputs.forEach(input => {\n  const nodeName = input.node;\n  const results = Array.isArray(input.json) ? input.json : [input.json];\n  \n  switch (nodeName) {\n    case 'vector-similarity-search':\n      searchResults.vectorResults = results.map(r => ({\n        ...r,\n        type: 'vector',\n        searchType: 'vector'\n      }));\n      break;\n    case 'tag-based-search':\n      searchResults.tagResults = results.map(r => ({\n        ...r,\n        type: 'tag',\n        searchType: 'tag'\n      }));\n      break;\n    case 'category-collection-search':\n      searchResults.categoryResults = results.map(r => ({\n        ...r,\n        type: 'category',\n        searchType: 'category'\n      }));\n      break;\n    case 'color-based-search':\n      searchResults.colorResults = results.map(r => ({\n        ...r,\n        type: 'color',\n        searchType: 'color'\n      }));\n      break;\n  }\n});\n\n// Combine all results into a unified format for the AI selection step\nconst combinedResults = [\n  {\n    type: 'vector',\n    results: searchResults.vectorResults,\n    query: queryData.databaseParams.vector.searchText,\n    count: searchResults.vectorResults.length\n  },\n  {\n    type: 'tags',\n    results: searchResults.tagResults,\n    query: queryData.databaseParams.tag.primaryTags,\n    count: searchResults.tagResults.length\n  },\n  {\n    type: 'category',\n    results: searchResults.categoryResults,\n    query: queryData.databaseParams.category,\n    count: searchResults.categoryResults.length\n  },\n  {\n    type: 'color',\n    results: searchResults.colorResults,\n    query: queryData.databaseParams.color,\n    count: searchResults.colorResults.length\n  }\n];\n\nreturn {\n  ...queryData,\n  searchResults: combinedResults,\n  step: 'database_results_aggregated',\n  retrievalTime: new Date().toISOString(),\n  totalResults: combinedResults.reduce((sum, result) => sum + result.count, 0)\n};"
      },
      "id": "aggregate-database-results",
      "name": "Aggregate Database Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 250]
    },
    {
      "parameters": {
        "operation": "text",
        "options": {
          "systemMessage": "You are VividWalls Product Selection AI, specialized in analyzing database search results and selecting the most relevant artwork for user inquiries.\n\n## YOUR ROLE:\nAnalyze multiple database search results (vector, tag, category, color-based) and intelligently select the top 5-8 most relevant artworks that best match the user's specific needs and preferences.\n\n## SELECTION CRITERIA:\n\n### RELEVANCE SCORING:\n1. **Direct Match** (40%): How well the artwork matches explicit user requirements\n2. **Contextual Fit** (25%): Suitability for the specified room type and function\n3. **Style Harmony** (20%): Alignment with user's aesthetic preferences\n4. **Color Compatibility** (15%): Color scheme match with user's space/preferences\n\n### DIVERSITY CONSIDERATIONS:\n- **Style Variety**: Include different approaches within user preferences\n- **Size Options**: Offer various size recommendations when appropriate\n- **Price Range**: Consider different price points within collections\n- **Collection Representation**: Show variety from relevant collections\n\n### QUALITY FACTORS:\n- **Search Result Confidence**: Prioritize high-confidence matches\n- **Multi-Query Validation**: Favor artworks appearing in multiple search results\n- **Collection Coherence**: Consider how pieces work together if multiple selected\n- **User Journey Stage**: Adapt selections based on browsing vs. purchase intent\n\n## ANALYSIS FRAMEWORK:\n\n### RESULT CONSOLIDATION:\n1. **Identify Overlaps**: Find artworks appearing in multiple search results\n2. **Score Aggregation**: Combine scores from different search methods\n3. **Relevance Ranking**: Rank all candidates by composite relevance score\n4. **Diversity Balancing**: Ensure variety while maintaining relevance\n\n### SELECTION LOGIC:\n1. **Primary Selections** (3-4 pieces): Highest relevance scores, direct matches\n2. **Alternative Options** (2-3 pieces): Good matches with style/size variety\n3. **Exploratory Suggestions** (1-2 pieces): Slightly different but potentially appealing\n\n### PRESENTATION OPTIMIZATION:\n- **Lead with Strongest Match**: First recommendation should be most confident\n- **Explain Selection Reasoning**: Provide clear rationale for each choice\n- **Highlight Key Features**: Emphasize aspects that match user needs\n- **Suggest Combinations**: Recommend pieces that work well together\n\n## OUTPUT FORMAT:\nProvide structured JSON with selected artworks and detailed reasoning:\n\n```json\n{\n  \"selectedArtworks\": [\n    {\n      \"id\": \"artwork_id\",\n      \"title\": \"Artwork Title\",\n      \"collection\": \"Collection Name\",\n      \"relevanceScore\": 0.95,\n      \"selectionReason\": \"Why this piece was selected\",\n      \"userMatchFactors\": [\"factor1\", \"factor2\", \"factor3\"],\n      \"recommendedSizes\": [\"24x36\", \"36x48\"],\n      \"placementSuggestions\": [\"above sofa\", \"focal wall\"],\n      \"styleNotes\": \"How it fits user's style preferences\",\n      \"colorHarmony\": \"How colors work with user's space\",\n      \"moodImpact\": \"Emotional effect in user's environment\",\n      \"priority\": \"primary|alternative|exploratory\"\n    }\n  ],\n  \"selectionSummary\": {\n    \"totalCandidates\": 12,\n    \"selectedCount\": 6,\n    \"primaryMatches\": 3,\n    \"alternativeOptions\": 2,\n    \"exploratoryPicks\": 1,\n    \"averageRelevance\": 0.87\n  },\n  \"presentationStrategy\": {\n    \"leadRecommendation\": \"artwork_id\",\n    \"groupingLogic\": \"How pieces are organized for presentation\",\n    \"narrativeFlow\": \"Story connecting the recommendations\",\n    \"nextSteps\": [\"suggested user actions\"]\n  },\n  \"alternativeSearches\": {\n    \"ifNotSatisfied\": [\"alternative search strategies\"],\n    \"relatedQueries\": [\"related searches to suggest\"],\n    \"refinementOptions\": [\"ways to narrow/broaden search\"]\n  },\n  \"confidence\": 0.92,\n  \"reasoning\": \"Overall selection strategy and logic\"\n}\n```\n\n## INSTRUCTIONS:\n1. **Analyze all search results** comprehensively across different query types\n2. **Score and rank candidates** using the relevance criteria framework\n3. **Select optimal mix** balancing relevance, diversity, and user needs\n4. **Provide detailed reasoning** for each selection and overall strategy\n5. **Optimize for user experience** considering browsing patterns and decision-making\n6. **Suggest presentation flow** for maximum engagement and conversion\n\nAnalyze the search results and select the most relevant artworks for this user inquiry."
        },
        "prompt": "=Analyze these database search results and select the top artworks for the user inquiry:\n\nOriginal User Inquiry: \"{{ $json.originalInquiry }}\"\n\nSearch Parameters Used:\n{{ JSON.stringify($json.searchParameters, null, 2) }}\n\nDatabase Search Results:\n{{ JSON.stringify($json.searchResults, null, 2) }}\n\nUser Context:\n- Room Type: {{ $json.roomType || 'Not specified' }}\n- Style Preference: {{ $json.stylePreference || 'Not specified' }}\n- Mood Preference: {{ $json.moodPreference || 'Not specified' }}\n- Session ID: {{ $json.sessionId }}\n\nSelect the 5-8 most relevant artworks from all search results, providing detailed reasoning for each selection and an optimal presentation strategy. Focus on relevance, diversity, and user experience optimization.",
        "model": "gpt-4-turbo-preview"
      },
      "id": "select-top-artworks",
      "name": "Select Top Artworks (Chain Step 2)",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "jsCode": "// Process artwork selection and prepare for bifurcation\nconst aiResponse = $input.first().json.choices?.[0]?.message?.content || '';\nconst originalData = $('select-top-artworks').first().json;\n\n// Parse JSON response from AI\nlet selectionResult;\ntry {\n  const jsonMatch = aiResponse.match(/```json\\s*([\\s\\S]*?)\\s*```/) || aiResponse.match(/{[\\s\\S]*}/);\n  if (jsonMatch) {\n    selectionResult = JSON.parse(jsonMatch[1] || jsonMatch[0]);\n  } else {\n    throw new Error('No valid JSON found in AI response');\n  }\n} catch (error) {\n  // Fallback: create basic selection\n  selectionResult = {\n    selectedArtworks: [\n      {\n        id: 'fallback_1',\n        title: 'Selected Artwork',\n        collection: 'Geometric Intersection',\n        relevanceScore: 0.8,\n        selectionReason: 'Fallback selection due to parsing error'\n      }\n    ],\n    confidence: 0.5\n  };\n}\n\n// Prepare bifurcation data for different workflow branches\nconst bifurcationData = {\n  // Main response data\n  mainResponse: {\n    ...originalData,\n    artworkSelection: selectionResult,\n    step: 'selection_complete',\n    selectionTime: new Date().toISOString()\n  },\n  \n  // Branch 1: Detailed Analysis Workflow\n  detailedAnalysisBranch: {\n    selectedArtworks: selectionResult.selectedArtworks,\n    analysisType: 'detailed',\n    requiresImageAnalysis: true,\n    requiresColorExtraction: true,\n    requiresStyleAnalysis: true,\n    branchType: 'detailed_analysis'\n  },\n  \n  // Branch 2: Personalization Workflow\n  personalizationBranch: {\n    userId: originalData.userId,\n    sessionId: originalData.sessionId,\n    userPreferences: {\n      roomType: originalData.roomType,\n      stylePreference: originalData.stylePreference,\n      moodPreference: originalData.moodPreference,\n      colorPreferences: originalData.colorPreferences\n    },\n    selectedArtworks: selectionResult.selectedArtworks,\n    branchType: 'personalization'\n  },\n  \n  // Branch 3: Recommendation Engine Workflow\n  recommendationBranch: {\n    baseSelections: selectionResult.selectedArtworks,\n    searchParameters: originalData.searchParameters,\n    findSimilar: true,\n    findComplementary: true,\n    generateAlternatives: true,\n    branchType: 'recommendations'\n  },\n  \n  // Branch 4: User Feedback Loop\n  feedbackBranch: {\n    sessionId: originalData.sessionId,\n    presentedArtworks: selectionResult.selectedArtworks,\n    awaitingFeedback: true,\n    feedbackTypes: ['like', 'dislike', 'maybe', 'more_info'],\n    branchType: 'feedback_loop'\n  }\n};\n\n// Determine which branches to activate based on selection confidence and user context\nconst activeBranches = [];\n\nif (selectionResult.confidence >= 0.8) {\n  activeBranches.push('detailedAnalysisBranch', 'personalizationBranch');\n} else {\n  activeBranches.push('recommendationBranch', 'feedbackBranch');\n}\n\n// Always include feedback loop for continuous improvement\nif (!activeBranches.includes('feedbackBranch')) {\n  activeBranches.push('feedbackBranch');\n}\n\nreturn {\n  ...bifurcationData.mainResponse,\n  bifurcation: {\n    activeBranches: activeBranches,\n    branchData: bifurcationData,\n    branchingTime: new Date().toISOString(),\n    totalBranches: activeBranches.length\n  }\n};"
      },
      "id": "prepare-bifurcation",
      "name": "Prepare Workflow Bifurcation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "detailed_analysis",
              "leftValue": "={{ $json.bifurcation.activeBranches }}",
              "rightValue": "detailedAnalysisBranch",
              "operator": {
                "type": "array",
                "operation": "contains"
              }
            },
            {
              "id": "personalization",
              "leftValue": "={{ $json.bifurcation.activeBranches }}",
              "rightValue": "personalizationBranch",
              "operator": {
                "type": "array",
                "operation": "contains"
              }
            },
            {
              "id": "recommendations",
              "leftValue": "={{ $json.bifurcation.activeBranches }}",
              "rightValue": "recommendationBranch",
              "operator": {
                "type": "array",
                "operation": "contains"
              }
            },
            {
              "id": "feedback_loop",
              "leftValue": "={{ $json.bifurcation.activeBranches }}",
              "rightValue": "feedbackBranch",
              "operator": {
                "type": "array",
                "operation": "contains"
              }
            }
          ]
        },
        "fallbackOutput": "extra"
      },
      "id": "workflow-bifurcation-switch",
      "name": "Workflow Bifurcation Switch",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "url": "https://n8n.vividwalls.blog/webhook/vividwalls-detailed-analysis",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "body",
              "value": "={{ JSON.stringify($json.bifurcation.branchData.detailedAnalysisBranch) }}"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "call-detailed-analysis-workflow",
      "name": "Call Detailed Analysis Workflow",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2220, 100]
    },
    {
      "parameters": {
        "url": "https://n8n.vividwalls.blog/webhook/vividwalls-personalization",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "body",
              "value": "={{ JSON.stringify($json.bifurcation.branchData.personalizationBranch) }}"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "call-personalization-workflow",
      "name": "Call Personalization Workflow",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2220, 200]
    },
    {
      "parameters": {
        "url": "https://n8n.vividwalls.blog/webhook/vividwalls-recommendations",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "body",
              "value": "={{ JSON.stringify($json.bifurcation.branchData.recommendationBranch) }}"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "call-recommendation-workflow",
      "name": "Call Recommendation Workflow",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2220, 400]
    },
    {
      "parameters": {
        "url": "https://n8n.vividwalls.blog/webhook/vividwalls-feedback-loop",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "body",
              "value": "={{ JSON.stringify($json.bifurcation.branchData.feedbackBranch) }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "call-feedback-loop-workflow",
      "name": "Call Feedback Loop Workflow",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2220, 500]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate responses from all active workflow branches\nconst allInputs = $input.all();\nconst mainData = $('prepare-bifurcation').first().json;\n\n// Process responses from different branches\nconst branchResponses = {\n  detailedAnalysis: null,\n  personalization: null,\n  recommendations: null,\n  feedbackLoop: null\n};\n\n// Map responses to their respective branches\nallInputs.forEach(input => {\n  const response = input.json;\n  if (response.branchType) {\n    switch (response.branchType) {\n      case 'detailed_analysis':\n        branchResponses.detailedAnalysis = response;\n        break;\n      case 'personalization':\n        branchResponses.personalization = response;\n        break;\n      case 'recommendations':\n        branchResponses.recommendations = response;\n        break;\n      case 'feedback_loop':\n        branchResponses.feedbackLoop = response;\n        break;\n    }\n  }\n});\n\n// Create comprehensive response combining all branch results\nconst finalResponse = {\n  // Core selection results\n  selectedArtworks: mainData.artworkSelection.selectedArtworks,\n  selectionSummary: mainData.artworkSelection.selectionSummary,\n  presentationStrategy: mainData.artworkSelection.presentationStrategy,\n  \n  // Enhanced data from branches\n  enhancedAnalysis: branchResponses.detailedAnalysis?.enhancedAnalysis || null,\n  personalizedRecommendations: branchResponses.personalization?.personalizedData || null,\n  additionalRecommendations: branchResponses.recommendations?.additionalArtworks || null,\n  feedbackMechanism: branchResponses.feedbackLoop?.feedbackSetup || null,\n  \n  // Metadata\n  sessionId: mainData.sessionId,\n  userId: mainData.userId,\n  originalInquiry: mainData.originalInquiry,\n  processingChain: {\n    step1: 'search_parameter_extraction',\n    step2: 'database_retrieval',\n    step3: 'artwork_selection',\n    step4: 'workflow_bifurcation',\n    step5: 'response_aggregation'\n  },\n  \n  // Performance metrics\n  metrics: {\n    totalProcessingTime: Date.now() - new Date(mainData.timestamp).getTime(),\n    activeBranches: mainData.bifurcation.activeBranches,\n    searchResultsCount: mainData.searchResults.reduce((sum, result) => sum + result.count, 0),\n    finalSelectionCount: mainData.artworkSelection.selectedArtworks.length,\n    overallConfidence: mainData.artworkSelection.confidence\n  },\n  \n  // Next steps and user actions\n  nextSteps: {\n    primaryAction: 'view_selected_artworks',\n    secondaryActions: ['request_more_info', 'refine_search', 'save_favorites'],\n    feedbackOptions: ['like', 'dislike', 'need_different_style', 'need_different_size'],\n    continuationPaths: ['similar_artworks', 'different_collections', 'room_specific_search']\n  },\n  \n  timestamp: new Date().toISOString(),\n  status: 'complete'\n};\n\nreturn finalResponse;"
      },
      "id": "aggregate-branch-responses",
      "name": "Aggregate Branch Responses",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2440, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "X-Processing-Chain",
                "value": "prompt-chain-bifurcated"
              }
            ]
          }
        }
      },
      "id": "send-final-response",
      "name": "Send Final Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2660, 300]
    }
  ],
  "connections": {
    "User Inquiry Webhook": {
      "main": [
        [
          {
            "node": "Parse User Inquiry",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse User Inquiry": {
      "main": [
        [
          {
            "node": "Extract Search Parameters (Chain Step 1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Search Parameters (Chain Step 1)": {
      "main": [
        [
          {
            "node": "Prepare Database Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Database Queries": {
      "main": [
        [
          {
            "node": "Split Query Types",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Query Types": {
      "main": [
        [
          {
            "node": "Prepare Real Database Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Real Database Queries": {
      "main": [
        [
          {
            "node": "Vector Similarity Search",
            "type": "main",
            "index": 0
          },
          {
            "node": "Tag-Based Search",
            "type": "main",
            "index": 0
          },
          {
            "node": "Category & Collection Search",
            "type": "main",
            "index": 0
          },
          {
            "node": "Color-Based Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Similarity Search": {
      "main": [
        [
          {
            "node": "Aggregate Database Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tag-Based Search": {
      "main": [
        [
          {
            "node": "Aggregate Database Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Category & Collection Search": {
      "main": [
        [
          {
            "node": "Aggregate Database Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Color-Based Search": {
      "main": [
        [
          {
            "node": "Aggregate Database Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Database Results": {
      "main": [
        [
          {
            "node": "Select Top Artworks (Chain Step 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Select Top Artworks (Chain Step 2)": {
      "main": [
        [
          {
            "node": "Prepare Workflow Bifurcation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Workflow Bifurcation": {
      "main": [
        [
          {
            "node": "Workflow Bifurcation Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Workflow Bifurcation Switch": {
      "main": [
        [
          {
            "node": "Call Detailed Analysis Workflow",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Call Personalization Workflow",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Call Recommendation Workflow",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Call Feedback Loop Workflow",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Call Detailed Analysis Workflow": {
      "main": [
        [
          {
            "node": "Aggregate Branch Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Personalization Workflow": {
      "main": [
        [
          {
            "node": "Aggregate Branch Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Recommendation Workflow": {
      "main": [
        [
          {
            "node": "Aggregate Branch Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Feedback Loop Workflow": {
      "main": [
        [
          {
            "node": "Aggregate Branch Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Branch Responses": {
      "main": [
        [
          {
            "node": "Send Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-02-23T10:00:00.000Z",
      "updatedAt": "2025-02-23T10:00:00.000Z",
      "id": "vividwalls",
      "name": "VividWalls"
    },
    {
      "createdAt": "2025-02-23T10:00:00.000Z",
      "updatedAt": "2025-02-23T10:00:00.000Z",
      "id": "prompt-chain",
      "name": "Prompt Chain"
    },
    {
      "createdAt": "2025-02-23T10:00:00.000Z",
      "updatedAt": "2025-02-23T10:00:00.000Z",
      "id": "bifurcation",
      "name": "Workflow Bifurcation"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-02-23T10:00:00.000Z",
  "versionId": "1"
} 